global _tmpl_print = "%.*s\n\0";
global _tmpl_int_to_string = "%d\0";
global _tmpl_float_to_string = "%#f\0";
global _tmpl_char_to_string = "%lc\0";
class "#dynarray" { #ptr, int, int }
class string { #dynarray }
extern fun asprintf(arg0: #ptr, arg1: #ptr, ..) -> int;
fun "char::to_string"(self: char) -> string {
    let buf_ptr: #ptr = <#ptr>(<#ptr>::#alloca());
    let len: int = <int>(<(#ptr, #ptr, ..) -> int>(asprintf)(<#ptr>(buf_ptr), <#ptr>(_tmpl_char_to_string), <char>(self)));
    let buf: #ptr = <#ptr>(*buf_ptr);
    let cap: int = <int>(<int>(len) + <int>(1));
    return string #{#dynarray #{<#ptr>(buf), <int>(len), <int>(cap)}};
}
fun "string::add_string"(self: string, other: string) -> string {
    let new_len: int = <int>(<int>(<() -> int>(<string>(self).len)()) + <int>(<() -> int>(<string>(other).len)()));
    let result_inner: #dynarray = <#dynarray>(<(int) -> #dynarray>(#dynarray::new)(<int>(new_len)));
    <void>(<(#ptr, int) -> void>(<#dynarray>(result_inner).extend)(<#ptr>(<#dynarray>(<string>(self).0).0), <int>(<() -> int>(<string>(self).len)())));
    <void>(<(#ptr, int) -> void>(<#dynarray>(result_inner).extend)(<#ptr>(<#dynarray>(<string>(other).0).0), <int>(<() -> int>(<string>(other).len)())));
    return string #{<#dynarray>(result_inner)};
}
fun "#dynarray::pop"(self: #dynarray) -> void {
    return <void>(if <bool>(<int>(<#dynarray>(self).1) > <int>(0)) <void>{
        exit <void>{
            exit <void>(castfrom <int>(<#dynarray>(self).1 = <int>(<int>(<#dynarray>(self).1) - <int>(1))));
        };
    } else <void>{
        exit <void>{
            exit <void>(castfrom <int>(<#dynarray>(self).1 = <int>(0)));
        };
    });
}
fun "string::to_string"(self: string) -> string {
    return <string>(self);
}
fun "int::to_string"(self: int) -> string {
    let buf_ptr: #ptr = <#ptr>(<#ptr>::#alloca());
    let len: int = <int>(<(#ptr, #ptr, ..) -> int>(asprintf)(<#ptr>(buf_ptr), <#ptr>(_tmpl_int_to_string), <int>(self)));
    let buf: #ptr = <#ptr>(*buf_ptr);
    let cap: int = <int>(<int>(len) + <int>(1));
    return string #{#dynarray #{<#ptr>(buf), <int>(len), <int>(cap)}};
}
extern fun memcpy(arg0: #ptr, arg1: #ptr, arg2: int) -> #ptr;
fun "#dynarray::extend"(self: #dynarray, add_buf: #ptr, add_len: int) -> void {
    <void>(<(int) -> void>(<#dynarray>(self).resize)(<int>(<int>(<#dynarray>(self).1) + <int>(add_len))));
    let shift_buf: #ptr = <#ptr>(<#ll_array<#byte>>::#gep(<#ptr>(<#dynarray>(self).0), <int>(0), <int>(<#dynarray>(self).1)));
    <#ptr>(<(#ptr, #ptr, int) -> #ptr>(memcpy)(<#ptr>(shift_buf), <#ptr>(add_buf), <int>(add_len)));
    return <void>{
        exit <void>(castfrom <int>(<#dynarray>(self).1 = <int>(<int>(<#dynarray>(self).1) + <int>(add_len))));
    };
}
fun "string::new"(contents: #ptr, len: int) -> string {
    let inner: #dynarray = <#dynarray>(<(int) -> #dynarray>(#dynarray::new)(<int>(len)));
    <void>(<(#ptr, int) -> void>(<#dynarray>(inner).extend)(<#ptr>(contents), <int>(len)));
    return string #{<#dynarray>(inner)};
}
fun "float::to_string"(self: float) -> string {
    let buf_ptr: #ptr = <#ptr>(<#ptr>::#alloca());
    let len: int = <int>(<(#ptr, #ptr, ..) -> int>(asprintf)(<#ptr>(buf_ptr), <#ptr>(_tmpl_float_to_string), <float>(self)));
    let buf: #ptr = <#ptr>(*buf_ptr);
    let cap: int = <int>(<int>(len) + <int>(1));
    return string #{#dynarray #{<#ptr>(buf), <int>(len), <int>(cap)}};
}
fun "string::len"(self: string) -> int {
    return <int>(<#dynarray>(<string>(self).0).1);
}
extern fun printf(arg0: #ptr, ..) -> int;
fun print(s: string) -> void {
    return <void>(castfrom <int>(<(#ptr, ..) -> int>(printf)(<#ptr>(_tmpl_print), <int>(<#dynarray>(<string>(s).0).1), <#ptr>(<#dynarray>(<string>(s).0).0))));
}
extern fun malloc(arg0: int) -> #ptr;
fun "#dynarray::new"(cap: int) -> #dynarray {
    let buf: #ptr = <#ptr>(<(int) -> #ptr>(malloc)(<int>(cap)));
    return #dynarray #{<#ptr>(buf), <int>(0), <int>(cap)};
}
extern fun free(arg0: #ptr) -> void;
fun "#dynarray::resize"(self: #dynarray, new_cap: int) -> void {
    return <void>(if <bool>(<int>(<#dynarray>(self).2) < <int>(new_cap)) <void>{
        let old_buf: #ptr = <#ptr>(<#dynarray>(self).0);
        let new_buf: #ptr = <#ptr>(<(int) -> #ptr>(malloc)(<int>(new_cap)));
        <#ptr>(<(#ptr, #ptr, int) -> #ptr>(memcpy)(<#ptr>(new_buf), <#ptr>(old_buf), <int>(<#dynarray>(self).1)));
        <void>(<(#ptr) -> void>(free)(<#ptr>(old_buf)));
        exit <void>{
            exit <void>(castfrom <int>(<#dynarray>(self).2 = <int>(new_cap)));
        };
    });
}
fun "#dynarray::push"(self: #dynarray, byte: #byte) -> void {
    <void>(<(int) -> void>(<#dynarray>(self).resize)(<int>(<int>(<#dynarray>(self).1) + <int>(1))));
    let push_ptr: #ptr = <#ptr>(<#ll_array<#byte>>::#gep(<#ptr>(<#dynarray>(self).0), <int>(0), <int>(<#dynarray>(self).1)));
    <int>{
        exit <int>(<#dynarray>(self).1 = <int>(<int>(<#dynarray>(self).1) + <int>(1)));
    }
    return <void>{
        exit <void>(castfrom <#byte>(*push_ptr = <#byte>(byte)));
    };
}
