import intrinsic;

class #dynarray {
    buf: #ptr,
    len: int,
    cap: int

    fun ::new(cap: int) -> #dynarray {
        let buf = #malloc(cap);
        #dynarray #{
            buf, len: 0, cap
        };
    }

    fun self.resize(new_cap: int) {
        if self.cap < new_cap {
            let old_buf = self.buf;
            let new_buf = #malloc(new_cap);
            #memcpy(new_buf, old_buf, self.len);
            self.buf = new_buf;
            self.cap = new_cap;
            #free(old_buf);
        }
    }

    fun self.extend(add_buf: #ptr, add_len: int) {
        self.resize(self.len + add_len);

        let shift_buf = #byte::#gep(self.buf, self.len);
        #memcpy(shift_buf, add_buf, add_len);

        self.len = self.len + add_len;
    }

    fun self.take(sub_len: int) -> #ptr {
        if self.len >= sub_len {
            self.len = self.len - sub_len;
            #byte::#gep(self.buf, self.len);
        } else {
            throw "cannot take element from array";
        }
    }
}

class string {
    inner: #dynarray
    fun ::new(contents: #ptr, len: int) -> string {
        let inner = #dynarray::new(len);
        inner.extend(contents, len);

        string #{ inner };
    }
    
    fun self.len() -> int {
        self.inner.len;
    }

    fun self.add_string(other: string) -> string {
        let new_len = self.len() + other.len();
        let result_inner = #dynarray::new(new_len);

        result_inner.extend(self.inner.buf, self.len());
        result_inner.extend(other.inner.buf, other.len());

        string #{
            inner: result_inner
        };
    }

    fun self.to_string() -> string {
        self;
    }
}

// class list<T> {
//     inner: #dynarray
// 
//     fun ::new() -> list<T> {
//         <list<T>> #{ inner: #dynarray::new(0) };
//     }
//     fun self.len() -> int {
//         (self.inner.len / T::size_of()).trunc().iround();
//     }
//     fun self.push(e: T) {
//         let buf = T::#alloca();
//         *buf = e;
//         self.inner.extend(buf, T::size_of());
//     }
//     fun self.pop() -> T {
//         let pop_ptr = self.take(T::size_of());
//         *pop_ptr;
//     }
//     fun self.get(i: int) -> T {
//         if 0 <= i && i < t {
//             let access_ptr = T::#gep(self.inner.buf, i);
//             *access_ptr;
//         } else {
//             throw "array index out of bounds";
//         }
//     }
//     fun self.set(i: int, t: T) -> T {
//         if 0 <= i && i < t {
//             let access_ptr = T::#gep(self.inner.buf, i);
//             *access_ptr = t;
//         } else {
//             throw "array index out of bounds";
//         }
//     }
// }

global _tmpl_print = "%.*s\n\0";

fun print(s: string) {
    #printf(_tmpl_print, s.inner.len, s.inner.buf);
}

global _tmpl_int_to_string = "%d\0";
global _tmpl_float_to_string = "%#f\0";
global _tmpl_char_to_string = "%lc\0";

fit class int {
    fun self.to_string() -> string {
        let buf_ptr = #ptr::#alloca();
        let len = #asprintf(buf_ptr, _tmpl_int_to_string, self);
        let buf: #ptr = *buf_ptr;
        let cap = len + 1;

        string #{
            inner: #dynarray #{ buf, len, cap }
        };
    }

    fun self.abs() -> int {
        #abs(self, false);
    }
    fun self.max(o: int) -> int {
        #smax(self, o);
    }
    fun self.min(o: int) -> int {
        #smin(self, o);
    }
    fun self.sign() -> int {
        if self > 0 {
            1;
        } else if self < 0 {
            -1;
        } else {
            0;
        }
    }
    fun self.count_ones() {
        #ctpop(self);
    }
    fun self.reverse_bits() {
        #bitreverse(self);
    }
    fun self.reverse_bytes() {
        #bswap(self);
    }
    fun self.leading_zeroes() {
        #ctlz(self, false);
    }
    fun self.trailing_zeroes() {
        #cttz(self, false);
    }
}

fit class float {
    fun self.to_string() -> string {
        let buf_ptr = #ptr::#alloca();
        let len = #asprintf(buf_ptr, _tmpl_float_to_string, self);
        let buf: #ptr = *buf_ptr;
        let cap = len + 1;

        string #{
            inner: #dynarray #{ buf, len, cap }
        };
    }

    fun self.abs() -> float {
        #fabs(self);
    }
    fun self.fma(multiplicand: float, addend: float) -> float {
        #fma(self, multiplicand, addend);
    }
    fun self.max(o: float) -> float {
        #maxnum(self, o);
    }
    fun self.min(o: float) -> float {
        #minnum(self, o);
    }
    fun self.exp() -> float {
        #exp(self);
    }
    fun self.exp2() -> float {
        #exp2(self);
    }
    fun self.expm1() -> float {
        #expm1(self);
    }
    fun self.log() -> float {
        #log(self);
    }
    fun self.log2() -> float {
        #log2(self);
    }
    fun self.log10() -> float {
        #log10(self);
    }
    fun self.log1p() -> float {
        #log1p(self);
    }
    fun self.sqrt() -> float {
        #sqrt(self);
    }
    fun self.cbrt() -> float {
        #cbrt(self);
    }
    fun self.hypot(y: float) -> float {
        #hypot(self, y);
    }
    fun self.pow(exp: float) -> float {
        #pow(self, exp);
    }
    fun self.powi(exp: int) -> float {
        #pow(self, exp);
    }
    fun self.sin() -> float {
        #sin(self);
    }
    fun self.cos() -> float {
        #cos(self);
    }
    fun self.tan() -> float {
        #tan(self);
    }
    fun self.asin() -> float {
        #asin(self);
    }
    fun self.acos() -> float {
        #acos(self);
    }
    fun self.atan() -> float {
        #atan(self);
    }
    fun self.atan2(x: float) -> float {
        #atan2(self, x);
    }
    fun self.sinh() -> float {
        #sinh(self);
    }
    fun self.cosh() -> float {
        #cosh(self);
    }
    fun self.tanh() -> float {
        #tanh(self);
    }
    fun self.asinh() -> float {
        #asinh(self);
    }
    fun self.acosh() -> float {
        #acosh(self);
    }
    fun self.atanh() -> float {
        #atanh(self);
    }
    fun self.erf() -> float {
        #erf(self);
    }
    fun self.erfc() -> float {
        #erfc(self);
    }
    fun self.lgamma() -> float {
        #lgamma(self);
    }
    fun self.tgamma() -> float {
        #tgamma(self);
    }
    fun self.ceil() -> float {
        #ceil(self);
    }
    fun self.floor() -> float {
        #floor(self);
    }
    fun self.trunc() -> float {
        #trunc(self);
    }
    fun self.round() -> float {
        #round(self);
    }
    fun self.iround() -> int {
        #lround(self);
    }
    fun self.nexttoward(twd: float) -> float {
        #nexttoward(self, twd);
    }
    fun self.sign() -> float {
        #copysign(1, self);
    }
    fun self.isinf() -> bool {
        #isinf(self);
    }
    fun self.isnan() -> bool {
        #isnan(self);
    }
}

fit class char {
    fun self.to_string() -> string {
        let buf_ptr = #ptr::#alloca();
        let len = #asprintf(buf_ptr, _tmpl_char_to_string, self);
        let buf: #ptr = *buf_ptr;
        let cap = len + 1;

        string #{
            inner: #dynarray #{ buf, len, cap }
        };
    }
}