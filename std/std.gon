import intrinsic;

class #dynarray {
    buf: #ptr,
    len: int,
    cap: int

    fun ::new(cap: int) -> #dynarray {
        let buf = #malloc(cap);
        #dynarray #{
            buf, len: 0, cap
        };
    }

    fun self.resize(new_cap: int) {
        if self.cap < new_cap {
            let old_buf = self.buf;
            let new_buf = #malloc(new_cap);
            #memcpy(new_buf, old_buf, self.len);
            #free(old_buf);
            self.cap = new_cap;
        }
    }

    fun self.push(byte: #byte) {
        self.resize(self.len + 1);
        
        let push_ptr = <#ll_array<#byte>>::#gep(self.buf, 0, self.len);
        self.len = self.len + 1;
        *push_ptr = byte;
    }

    fun self.pop() {
        if self.len > 0 {
            self.len = self.len - 1;
        } else {
            self.len = 0;
        }
    }

    fun self.extend(add_buf: #ptr, add_len: int) {
        self.resize(self.len + add_len);

        let shift_buf = <#ll_array<#byte>>::#gep(self.buf, 0, self.len);
        #memcpy(shift_buf, add_buf, add_len);

        self.len = self.len + add_len;
    }
}

class string {
    inner: #dynarray
    fun ::new(contents: #ptr, len: int) -> string {
        let inner = #dynarray::new(len);
        inner.extend(contents, len);

        string #{ inner };
    }
    
    fun self.len() -> int {
        self.inner.len;
    }

    fun self.add_string(other: string) -> string {
        let new_len = self.len() + other.len();
        let result_inner = #dynarray::new(new_len);

        result_inner.extend(self.inner.buf, self.len());
        result_inner.extend(other.inner.buf, other.len());

        string #{
            inner: result_inner
        };
    }

    fun self.to_string() -> string {
        self;
    }
}

global _tmpl_print = "%.*s\n\0";

fun print(s: string) {
    #printf(_tmpl_print, s.inner.len, s.inner.buf);
}

global _tmpl_int_to_string = "%d\0";
global _tmpl_float_to_string = "%#f\0";
global _tmpl_char_to_string = "%lc\0";

fit class int {
    fun self.to_string() -> string {
        let buf_ptr = #ptr::#alloca();
        let len = #asprintf(buf_ptr, _tmpl_int_to_string, self);
        let buf: #ptr = *buf_ptr;
        let cap = len + 1;

        string #{
            inner: #dynarray #{ buf, len, cap }
        };
    }
}

fit class float {
    fun self.to_string() -> string {
        let buf_ptr = #ptr::#alloca();
        let len = #asprintf(buf_ptr, _tmpl_float_to_string, self);
        let buf: #ptr = *buf_ptr;
        let cap = len + 1;

        string #{
            inner: #dynarray #{ buf, len, cap }
        };
    }
}

fit class char {
    fun self.to_string() -> string {
        let buf_ptr = #ptr::#alloca();
        let len = #asprintf(buf_ptr, _tmpl_char_to_string, self);
        let buf: #ptr = *buf_ptr;
        let cap = len + 1;

        string #{
            inner: #dynarray #{ buf, len, cap }
        };
    }
}